```ruby
# rubocop:disable all
# frozen_string_literal: true

# rails send_mail_incomplete_daily_schedule_task
desc '本日工事予定のデータに完了遅延通知メールを予約する'
task send_mail_incomplete_daily_schedule_task: :environment do
office = Office.find_by(id: Settings.send_mail_incomplete_daily_schedule_task.office_id.kashima)
pj_ids = office.projects.ids


# 作業が完了しているタスクはsend_mail_incomplete_daily_schedule_task.sendedをtrueに変更

finished_scope = DetailDailyScheduleTask.left_joins(
detail_daily_schedule: {
daily_schedule: {
incidental_construction: :conservation_report
}
}
)
.where(daily_schedule: { start_at: [Date.today, Date.yesterday] })
.where(approval_status: [:task_finished, :construction_stop])
  

finished_scope = finished_scope.where(
daily_schedule: { project_id: pj_ids }
).or(
finished_scope.where(conservation_report: { project_id: pj_ids})
).distinct

finished_scope = finished_scope.includes(detail_daily_schedule: :daily_schedule)

finished_scope.each do |task|
daily_schedule = task.daily_schedule
working_time_str = task.working_finished_time

# working_finished_time がnilや空文字だとTime.parseでエラー
next if working_time_str.blank?

time = Time.parse(working_time_str)
finish_at = daily_schedule.start_at.to_datetime.in_time_zone(Rails.application.config.time_zone).change(hour: time.hour, min: time.min)

finish_at += 1.day if task.finished_type.next_day?

send_reserve_at = finish_at + 30.minutes


send_mail = SendMailIncompleteDailyScheduleTask.find_or_initialize_by(detail_daily_schedule_task_id: task.id)

send_mail.update(sended: true, send_reserve_at: send_reserve_at)
end

  

# 作業完了していないタスクはメール送信を設定
today_unfinished_scope = DetailDailyScheduleTask.left_joins(
detail_daily_schedule: {
daily_schedule: {
incidental_construction: :conservation_report
}
}
)
.where(daily_schedule: { start_at: Date.today })

today_unfinished_scope = today_unfinished_scope.where(
daily_schedule: { project_id: pj_ids}
).or(
today_unfinished_scope.where(conservation_report: { project_id: pj_ids})
).distinct

today_unfinished_scope = today_unfinished_scope.where(approval_status: :task_started)
.includes(detail_daily_schedule: :daily_schedule)
.includes(:send_mail_incomplete_daily_schedule_task)

job_to_schedule = []

today_unfinished_scope.each do |task|
daily_schedule = task.daily_schedule
send_mail = SendMailIncompleteDailyScheduleTask.find_or_initialize_by(detail_daily_schedule_task_id: task.id)
working_time_str = task.working_finished_time

# working_finished_time がnilや空文字だとTime.parseでエラー
next if working_time_str.blank?  

time = Time.parse(working_time_str)
finish_at = daily_schedule.start_at.to_datetime.in_time_zone(Rails.application.config.time_zone).change(hour: time.hour, min: time.min)

finish_at += 1.day if task.finished_type.next_day?
send_reserve_at = finish_at + 30.minutes

  

# 送信予約時間を過ぎて未送信ならすぐ送信する。まだ過ぎていないなら予約する。

if send_reserve_at < Time.current && send_mail.sended == false

send_mail.send_reserve_at = send_reserve_at

send_mail.save!

SendMailIncompleteDailyScheduleTaskMailer.notification(task.id).deliver_now

elsif send_mail.send_reserve_at != send_reserve_at && send_mail.sended == false

# 予約時間が合わないなら予約する。一致するなら予約済みとして何もしない

send_mail.send_reserve_at = send_reserve_at

send_mail.save!

job_to_schedule << { task_id: task.id, send_at: send_reserve_at }

end

end

  

job_to_schedule.each do |job|

SendMailIncompleteDailyScheduleTaskMailer.notification(job[:task_id]).deliver_later(wait_until: job[:send_at])

end

  

if SendMailIncompleteDailyScheduleTask.count > 300

# データ量が増えてきたら削除する

SendMailIncompleteDailyScheduleTask.where('created_at < ?', 1.weeks.ago).delete_all

end

end

# rubocop:enable all
```