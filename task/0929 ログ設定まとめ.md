### ログ出力の考え方
目標：ECS移行時に標準出力に変更する必要があるため、ファイルに直接書き込む設定は避けたい。標準出力をしていればOK.
疑問点：標準出力さえできていれば、システムログへ出力していようが、指定ファイルへredirectしていようがどちらでも構わないのか。

## Sidekiqの標準出力先をredirectしたい場合
```ruby
# config/initializers/sidekiq.rb (例)

Sidekiq.configure_server do |config|
  config.redis = { url: "redis://#{ENV['KVS_HOST']}:6379/#{ENV.prefix_fetch('SIDEKIQ_REDIS_DB', 8)}" }
  config.default_job_options = { retry: 5 }

  # ここを修正します
  # 環境変数に応じて切り替えたい場合は、このまま if/else 構造を使用
  # 今回はファイル出力のみなので、直接パスを指定
  config.logger = Sidekiq::Logger.new(Rails.root.join('log', "sidekiq.log"))
  config.logger.level = Logger::INFO
end
```

## アプリケーションログをシステムログへ標準出力する場合
https://github.com/Bee2B/eneos-spm/issues/7254

## 出力方法
- アプリケーションログ
	- 環境変数の設定で標準出力可能
- nginx
	- ファイルに直接書き込み
	- EC2で標準出力に変更しようと思うと、色々調べるところからスタート
- sidekiq
	- システムログに標準出力
- puma
	- 標準出力をredirect
- cron
	- crontab.log
		- 指定したコマンドの標準出力を標準エラーをredirect
	- /var/log/cron
		- cron自体の動作を記録


# nginxの標準出力設定について
大変重要なご指摘とご質問です。

まず、ほとんどのLinuxディストリビューションでは、**NGINXサービス用のSystemdユニットファイル（`nginx.service`）は存在します。**ファイルが見つからない場合、その理由と、ログの挙動について解説します。

---

## NGINXのログとSystemdの挙動

### 1. `nginx.service`ファイルが見つからない理由

`/etc/systemd/system/nginx.service` などにファイルがない場合、以下の理由が考えられます。

- **ディストリビューションごとの配置場所の違い:** Red Hat系（RHEL/CentOS/Amazon Linux）やDebian/Ubuntu系など、ディストリビューションによってユニットファイルの配置場所が異なります。通常は `/usr/lib/systemd/system/` や `/lib/systemd/system/` にあり、これはシンボリックリンクやオーバーライドによって `/etc/systemd/system/` にリンクされます。
    
- **Systemd管理外の起動:** NGINXをSystemdではなく、古い `sysvinit` スクリプトや手動で起動している可能性があります。
    
- **名前の違い:** ユニット名が `nginx.service` ではなく `nginx` や `httpd` のような別名かもしれません。
    

確認コマンド:

まずは以下のコマンドで、SystemdがNGINXをどのように認識しているか確認してみてください。

Bash

```
systemctl status nginx
# もしくは
systemctl status nginx.service
# または、ユニットファイルがどこにあるか探す
find /etc/systemd/ -name "nginx.service"
find /usr/lib/systemd/ -name "nginx.service"
```

### 2. `nginx.conf`を`/dev/stdout`にするだけでは不十分な理由

結論から言うと、**`nginx.conf` で `access_log /dev/stdout;` にするだけでは、journaldでログを確認できない可能性が高いです。**

これは、Systemdのサービスタイプと、ログの捕捉方法に理由があります。

#### 理由 (1): NGINXのフォーク（`Type=forking`）

ほとんどのLinux環境で、NGINXのSystemdユニットファイルは、通常サービスタイプが `Type=forking` に設定されています。

- `Type=forking`: NGINXのマスタープロセスが起動した後、すぐに**バックグラウンドに移行（フォーク）**します。
    
- このフォークにより、Systemdは元の**標準出力ストリームとの接続を失ってしまいます**。結果として、NGINXが `/dev/stdout` に書き込んでも、Systemd（ジャーナル）はそれを捕捉できません。
    

#### 理由 (2): Systemdのログ捕捉方法

Systemdがアプリケーションの標準出力/エラー出力を捕捉し、journaldに記録できるのは、サービスタイプが `Type=simple` や `Type=exec` のように、**フォークせずにフォアグラウンドで実行され続ける**プロセスの場合です。

### 解決策：Systemdの設定をモダンな形式に変更する

NGINXのログをjournaldで確実に捕捉するには、**Systemdユニットファイルを修正し、NGINXをフォアグラウンドモードで実行する**必要があります。

1. **NGINXの設定 (`nginx.conf`)**:
    
    Nginx
    
    ```
    access_log /dev/stdout;
    error_log /dev/stderr;
    ```
    
2. Systemdの設定 (nginx.service の修正):
    
    ユニットファイルの [Service] セクションを以下のように変更（または /etc/systemd/system/nginx.service.d/ ディレクトリでオーバーライド）します。
    
    - `Type` を `simple` または `exec` に変更。
        
    - `PIDFile` を削除。
        
    - `ExecStart` コマンドに、NGINXをフォアグラウンドで起動するための `-g 'daemon off;'` オプションを追加。
        
    
    Ini, TOML
    
    ```
    [Service]
    Type=exec                  # simple でも可
    # PIDFile=/run/nginx.pid   # PIDファイルの設定は不要になるためコメントアウトまたは削除
    
    # NGINXをデーモン化せずにフォアグラウンドで起動する
    ExecStart=/usr/sbin/nginx -g 'daemon off;' 
    
    # 標準出力と標準エラー出力は journald に送る
    StandardOutput=journal
    StandardError=inherit
    
    # ...
    ```
    

この修正により、NGINXはフォアグラウンドで実行され、`stdout`/`stderr` ストリームはSystemdに維持されるため、**journaldが確実にログを捕捉**できるようになります。

**【次のステップ】**

まずは `systemctl status nginx` コマンドでユニットファイルの場所を特定し、もし `Type=forking` であれば、上記のように `Type=exec` と `daemon off;` に変更してサービスを再起動してみてください。